package githubreleasepublish

import (
	"fmt"
	"strings"

	cidsdk "github.com/cidverse/cid-sdk-go"
	"github.com/cidverse/cidverseutils/version"
	"github.com/go-playground/validator/v10"
)

const URI = "builtin://actions/github-release-publish"

type Action struct {
	Sdk cidsdk.SDKClient
}

type Config struct {
	GitHubToken string `json:"github_token"  env:"GITHUB_TOKEN"`
}

func (a Action) Metadata() cidsdk.ActionMetadata {
	return cidsdk.ActionMetadata{
		Name:        "github-release-publish",
		Description: "Publishes a new release on GitHub, including the release notes and artifacts.",
		Category:    "publish",
		Scope:       cidsdk.ActionScopeProject,
		Rules: []cidsdk.ActionRule{
			{
				Type:       "cel",
				Expression: `hasPrefix(ENV["NCI_REPOSITORY_REMOTE"], "https://github.com/") && CID_WORKFLOW_TYPE == "release"`,
			},
		},
		Access: cidsdk.ActionAccess{
			Environment: []cidsdk.ActionAccessEnv{
				{
					Name:        "GITHUB_TOKEN",
					Description: "The GitHub token to use for creating the release.",
					Required:    true,
				},
			},
			Executables: []cidsdk.ActionAccessExecutable{},
		},
		Input: cidsdk.ActionInput{
			Artifacts: []cidsdk.ActionArtifactType{
				{
					Type: "changelog",
				},
				{
					Type: "binary",
				},
			},
		},
	}
}

func (a Action) GetConfig(d *cidsdk.ProjectActionData) (Config, error) {
	cfg := Config{}
	cidsdk.PopulateFromEnv(&cfg, d.Env)

	// validate
	validate := validator.New(validator.WithRequiredStructEnabled())
	err := validate.Struct(cfg)
	if err != nil {
		return cfg, err
	}

	return cfg, nil
}

func (a Action) Execute() (err error) {
	// query action data
	d, err := a.Sdk.ProjectActionDataV1()
	if err != nil {
		return err
	}

	// parse config
	cfg, err := a.GetConfig(d)
	if err != nil {
		return err
	}

	// changelog
	changelogFile := cidsdk.JoinPath(d.Config.TempDir, "github.changelog")
	changelogErr := a.Sdk.ArtifactDownload(cidsdk.ArtifactDownloadRequest{
		ID:         "root|changelog|github.changelog",
		TargetFile: changelogFile,
	})

	// options
	releaseOpts := []string{"--verify-tag"}
	if changelogErr == nil { // use changelog generated by pipeline, default to GitHub auto generated release notes if not available
		releaseOpts = append(releaseOpts, fmt.Sprintf("-F %q", changelogFile))
	} else {
		releaseOpts = append(releaseOpts, "--generate-notes")
	}

	// prerelease
	if !version.IsStable(d.Env["NCI_COMMIT_REF_NAME"]) {
		releaseOpts = append(releaseOpts, "--prerelease")
	}

	// release artifacts
	artifacts, err := a.Sdk.ArtifactList(cidsdk.ArtifactListRequest{Query: `artifact_type == "binary"`})
	if err != nil {
		return err
	}
	_ = a.Sdk.Log(cidsdk.LogMessageRequest{Level: "info", Message: "searching for artifacts to include in the release", Context: map[string]interface{}{"artifact_count": len(*artifacts)}})
	for _, artifact := range *artifacts {
		targetFile := cidsdk.JoinPath(d.Config.TempDir, artifact.Name)
		var dlErr = a.Sdk.ArtifactDownload(cidsdk.ArtifactDownloadRequest{
			ID:         artifact.ID,
			TargetFile: targetFile,
		})
		if dlErr != nil {
			_ = a.Sdk.Log(cidsdk.LogMessageRequest{Level: "warn", Message: "failed to retrieve release artifact", Context: map[string]interface{}{"artifact": fmt.Sprintf("%s-%s", artifact.Module, artifact.Name)}})
			continue
		}

		releaseOpts = append(releaseOpts, fmt.Sprintf("'%s#%s/%s'", targetFile, artifact.Module, artifact.Name))
	}

	// create release
	releaseResult, err := a.Sdk.ExecuteCommand(cidsdk.ExecuteCommandRequest{
		Command: fmt.Sprintf(`gh release create %q %s`, d.Env["NCI_COMMIT_REF_NAME"], strings.Join(releaseOpts, " ")),
		WorkDir: d.ProjectDir,
		Env: map[string]string{
			"GH_TOKEN": cfg.GitHubToken,
		},
	})
	if err != nil {
		return err
	} else if releaseResult.Code != 0 {
		return fmt.Errorf("github release creation failed, exit code %d", releaseResult.Code)
	}

	return nil
}
